C++-\/implementation of Python-\/like zip-\/ and enumerate-\/iterators which can be used in range-\/based for loops along with structured bindings to iterate over multiple containers at the same time. Requires C++17.\hypertarget{index_autotoc_md1}{}\doxysection{Properties}\label{index_autotoc_md1}
The {\ttfamily zip}-\/class is a container-\/wrapper for arbitrary iterable containers. It provides the member functions {\ttfamily begin()} and {\ttfamily end()} enabling it to be used in range-\/based for loops to iterate over multiple containers at the same time. The {\ttfamily enuerate}-\/function is a special case of {\ttfamily zip} and uses a \char`\"{}counting container\char`\"{} (similar to {\ttfamily std\+::ranges\+::iota}) to provide an index. Additionally, const-\/versions exist which do not allow the manipulation of the container elements.\hypertarget{index_autotoc_md2}{}\doxysection{Documentation}\label{index_autotoc_md2}
\href{https://timmifixedit.github.io/IteratorTools/html/index.html}{\texttt{ Doxygen}}\hypertarget{index_autotoc_md3}{}\doxysection{Code Examples}\label{index_autotoc_md3}
The syntax is mostly similar to Python\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{\#include <vector>}
\DoxyCodeLine{\#include <list>}
\DoxyCodeLine{\#include "Iterators.hpp"}
\DoxyCodeLine{}
\DoxyCodeLine{using namespace iterators;}
\DoxyCodeLine{std::list<std::string> strings\{"a", "b", "c"\};}
\DoxyCodeLine{std::vector<int> numbers\{1, 2, 3\};}
\DoxyCodeLine{for (auto [string, number] : zip(strings, numbers)) \{}
\DoxyCodeLine{    // 'string' and 'number' are references to the container element}
\DoxyCodeLine{    string += std::to\_string(number); }
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{// now 'strings' contains \{"a1", "b2", "c3"\}}
\end{DoxyCode}


The for loop uses so called {\ttfamily Zip\+Iterator}s which point to tuples which in turn contain references to the container elements. Therefore, no copying occurs and manipulation of the container elements is possible. Observe that the structured binding captures by value (since the values are themselves references).

If you want to prohibit manipulation, you can use {\ttfamily const\+\_\+zip} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{using namespace iterators;}
\DoxyCodeLine{std::list<std::string> strings\{"a", "b", "c"\};}
\DoxyCodeLine{std::vector<int> numbers\{1, 2, 3\};}
\DoxyCodeLine{for (auto [string, number] : const\_zip(strings, numbers)) \{}
\DoxyCodeLine{    // string += std::to\_string(number);  error, string is readonly!}
\DoxyCodeLine{    std::cout << string << " " << number << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}


Additionally, you can use {\ttfamily zip\+\_\+i} to manually zip iterators or pointers\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{using namespace iterators;}
\DoxyCodeLine{std::list<std::string> strings\{"a", "b", "c"\};}
\DoxyCodeLine{std::vector<int> numbers\{1, 2, 3\};}
\DoxyCodeLine{auto zipBegin = zip\_i(strings.begin(), numbers.begin());}
\DoxyCodeLine{auto zipEnd = zip\_i(strings.end(), numbers.end());}
\DoxyCodeLine{while (zipBegin != zipEnd) \{}
\DoxyCodeLine{    auto [s, num] = *zipBegin;}
\DoxyCodeLine{    // ...}
\DoxyCodeLine{    ++zipBegin;}
\DoxyCodeLine{\}}
\end{DoxyCode}


{\ttfamily Zip\+Iterators} support the same operations as the least powerful underlying iterator. For example, if you zip a random access iterator (e.\+g. from {\ttfamily std\+::vector}) and a bidirectional iterator (e.\+g. from {\ttfamily std\+::list}), then the resulting {\ttfamily Zip\+Iterator} will only support bidirectional iteration but no random access.

As in Python, the shortest range decides the overall range\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{using namespace iterators;}
\DoxyCodeLine{std::list<std::string> strings\{"a", "b", "c"\};}
\DoxyCodeLine{std::vector<int> numbers\{1, 2, 3, 4, 5, 6\};}
\DoxyCodeLine{for (auto [string, number] : zip(strings, numbers)) \{}
\DoxyCodeLine{    std::cout << string << " " << number << " | "}
\DoxyCodeLine{\}}
\DoxyCodeLine{// prints a 1 | b 2 | c 3 |}
\end{DoxyCode}


The {\ttfamily enumerate}-\/function works similarly. 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{using namespace iterators;}
\DoxyCodeLine{std::list<std::string> strings\{"a", "b", "c"\};}
\DoxyCodeLine{for (auto [index, string] : enumerate(strings)) \{}
\DoxyCodeLine{    string += std::to\_string(index); }
\DoxyCodeLine{\}}
\DoxyCodeLine{// now 'strings' contains \{"a0", "b1", "c2"\}}
\end{DoxyCode}


Also, an optional offset can be specified\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{for (auto [index, string] : enumerate(strings, 4)) \{ // index starts from 4}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


And as with {\ttfamily zip}, a const version ({\ttfamily const\+\_\+enumerate}) exists.

In case temporary containers are used, {\ttfamily zip} and {\ttfamily enumerate} will take ownership of the containers to guarantee well-\/defined memory access. 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{for (auto [index, number] : enumerate(std::array\{53, 21, 17\})) \{}
\DoxyCodeLine{    // enumerate takes ownership of the array. The elements}
\DoxyCodeLine{    // can safely be accessed and manipulated}
\DoxyCodeLine{\}}
\end{DoxyCode}
 